= midi-message

== Summary

MIDI messages, objectified in Ruby

== Features

* All message types and components
* YAML Dictionary of MIDI constants
	
== Install

* gem install midi-message

== Usage

  require 'midi-message'

  # there are three ways to instantiate a message
  
  MIDIMessage.parse(0x90, 0x40, 0x40)
  MIDIMessage::NoteOn.new(0, 64, 64)  
  MIDIMessage::NoteOn["E4"].new(0, 100)

  # any of those three expressions will give you

  # #<MIDIMessage::NoteOn:0x9c1c240
  # @channel=0,
  # @data=[64, 64],
  # @name="E4",
  # @note=64,
  # @status=[9, 0],
  # @velocity=64,
  # @verbose_name="Note On: E4">

  # instantiating sysex messages works basically the same way

  MIDIMessage.parse(0xF0, 0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x7F, 0x00, 0x41, 0xF7)
  
  # or in a more object oriented way
  
  node = SystemExclusive::Node.new(0x41, 0x42, :device_id => 0x10)  
  SystemExclusive::Command.new([0x40, 0x7F, 0x00], 0x00, :node => node)
  
  # or
  
  node.command([0x40, 0x7F, 0x00], 0x00)
   
  # or using a prototype message that has no node
  
  prototype = SystemExclusive::Command.new([0x40, 0x7F, 0x00], 0x00)
  node.new_message_from(prototype) 
  
  # all of these will give you

  # #<MIDIMessage::SystemExclusive::Command:0x9c1e57c
  # @address=[64, 0, 127],
  # @checksum=[65],
  # @data=[0],
  # @node=
  #  #<MIDIMessage::SystemExclusive::Node:0x9c1e5a4
  #   @device_id=16,
  #   @manufacturer=65,
  #   @model_id=66>>

see these, more examples and more explanation {here}[https://github.com/arirusso/midi-message/tree/master/examples]

== Documentation

* {rdoc}[http://rdoc.info/gems/midi-message]

== Author

* {Ari Russo}[http://github.com/arirusso] <ari.russo at gmail.com>

== License

Apache 2.0, See the file LICENSE

Copyright (c) 2011 Ari Russo
